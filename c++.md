# 中缀表达式转后缀表达式

**比如：1）中缀表达式 15+(24-6)/4*2+18 如何转后缀表达式 15#24#6#-4#/2#*+18#+**

**2）中缀表达式 81/3+67*(3+12)-24*5 如何转后缀表达式81#3#/67#3#12#+*+24#5#*-**

**3）中缀表达式 61+(33-5/21)*(3+9)+8 后缀表达式61#33#5#21#/-3#9#+*+8#+**

做从左向右扫描，转化过程如下：

1、遇到操作数时直接输出，操作数结束后加#

2、遇到操作符，与栈顶操作符比较优先级

2.1 如果栈为空，或者栈顶元素为’(’，直接加入栈； *栈顶元素优先级最低的两种情况*

2.2 如果优先级比栈顶操作数高，直接加入栈；

2.3 如果优先级比栈顶操作符低或者相等，则弹出栈顶元素并输出，再次进行对比，直到自己入栈

3、遇到括号时：

3.1 如果为左括号，直接加入栈

3.2 如果为右括号，依次弹出栈顶元素并输出，直到遇到左括号，并弹出

4、最后将栈顶元素依次弹出并输出。





# 基本

以/*开始，
*/结束的是多行注释

#### 函数

pow(2,3)意思是2的3次方
sqrt(5)意思是根号5
exp(x)意思是e**x
fabs(x)就是|x|

符号%lf专为double类型设计，表示输出一个double类型浮点数
%5.2lf     5:表示输出的宽度为5个字符。如果数字的长度少于5个字符，那么输出会在左侧用空格填充至5个字符。(=4.4就为=  4.4)

```c++
#include <stdio.h>
int main()
{
	int n = 0;
    double e = 1.0,term = 1.0,eps;
    scanf("%lf",&eps);

    do{
        n ++;
        term /= n;
        e += term;
    }while(term > eps);
    n += 1;
    printf("i=%d\n",n);
    printf("e=%.6lf",e);
	return 0;
}
```

#### 头文件

1. 输入／输出函数(头文件为 stdio.h)：用于完成输入／输出功能；
2. 字符串函数(头文件为 string.h)：用于字符串操作和处理；
3. 数学函数(头文件为 math.h)：用于数学函数计算；
4. 内存管理函数(头文件为 stdlib.h)：用于内存管理；
5. 日期和时间函数(头文件为 time.h)：用于日期、时间的转换操作；
6. 接口函数(头文件为 dos.h)：用于与 DOS、BIOS 和硬件的接口



- 求字符串长度函数：`strlen( )`
- 字符串拷贝函数：`strcpy( )`
- 字符串连接函数：`strcat( )`
- 字符串比较函数：`strcmp( )`



#### fgets

`fgets` 是 C 语言中的一个标准库函数，用于从指定的流（如文件或标准输入）中读取一行，并将其存储在提供的缓冲区中。函数原型通常如下：

```c
char *fgets(char *str, int n, FILE *stream);
```

- `str`：指向一个字符数组的指针，即缓冲区，用于存储读取到的字符串。
- `n`：要读取的最大字符数（包括空字符 '\0'）。通常，你会传递缓冲区的大小作为这个值，以确保不会超出缓冲区的边界。
- `stream`：指向 `FILE` 对象的指针，代表要从中读取数据的输入流。

例如

```c
#include <stdio.h>  
  
int main() {  
    FILE *fp = fopen("example.txt", "r");  
    if (fp == NULL) {  
        perror("Error opening file");  
        return 1;  
    }  
  
    char buffer[100]; // 假设缓冲区大小为100字节  
    if (fgets(buffer, sizeof(buffer), fp) != NULL) {  
        printf("Read line: %s", buffer);  
    } else {  
        perror("Error reading from file");  
    }  
  
    fclose(fp);  
    return 0;  
}
```

#### 重置文件指针

```c
fseek(fp, 0, SEEK_SET);
```

使用fseek函数将文件指针重置到文件的开始位置，以便重新读取文件内容

#### strtok函数

```c
char* token = strtok(buffer, ",\n");
```

buffer是要分割的字符串，“,\n”是分隔符的字符集合（，和\n）
`strtok` 函数会查找 `buffer` 中第一个分隔符（逗号或换行符），并将其替换为字符串结束符 `\0`。然后，它返回一个指向找到的第一个子串（即第一个 token）的指针。这个子串是从 `buffer` 的开始位置到第一个分隔符（不包括分隔符）之间的内容。

```c
token = strtok(NULL,",\n");
```

`strtok` 函数再次被调用，但这次它的第一个参数是 `NULL`。这告诉 `strtok` 函数继续从上一次调用停止的地方开始分割字符串。

#### 常量

指数：12.34e3(代表12.34x10^3^), -34.87e-25(代表-34.87x10^-25^), 0.145E-25(代表0.145x10^-25^)
e或E前必须有数字，且e或E之后必须为整数。

字符：用撇号括起来一个字符，如‘a’,’3’,’#’    **c格式符**

字符串：用双撇号括起来的若干字符，如“girl”    **s格式符**

符号常量：指定一个符号名称代表一个常量
#define  PI  3.1416

常变量：const int a=3;
变量存在期间其值不能改变

#### 算术运算

两个实数相除结果是双精度实数，两个整数相除结果为整数

++i,- - i(使用i之前，先使i的值加(减)1)
i++,i - -(使用i之后，使i的值加(减)1)

##### 强制类型转换运算符

(double)a    (将a转换为double型)
(int)(x+y)      (将x+y值转换为int型)
(float)(5%3)    (将5%3的值转换为float型)

#### 输出

%7.2f指定数据占7列，其中小数占2列(向右对齐)
%-7.2f(向左对齐)，加-号

putchar(输出字符)、getchar(输入字符)、puts(输出字符串)、gets(输入字符串)

#### 运算符优先级

| 标记      | 操作符       | 类型 | 优先级 |
| --------- | ------------ | ---- | ------ |
| ++ --     | 自增、自减   | 后缀 | 16     |
| ++ --     | 自增、自减   | 前缀 | 15     |
| !         | 逻辑非       | 单目 | 15     |
| + -       | 正号，负号   | 单目 | 15     |
| * / %     | 乘、除、取余 | 双目 | 13     |
| + -       | 加、减       | 双目 | 12     |
| < > <= >= | 关系         | 双目 | 10     |
| == !=     | 相等、不相等 | 双目 | 9      |
| &&        | 逻辑与       | 双目 | 5      |
| \|\|      | 逻辑或       | 双目 | 4      |
| =         | 赋值         | 双目 | 2      |

关系运算符的优先级==低于==算术运算符
关系运算符的优先级==高于==赋值运算符

‘>’运算符是自左至右的结合方向

#### 条件运算符

max=(a>b) ? a:b;       //“？”是条件运算符，若a>b为真则max=a,假则max=b



# switch语句

switch(){

​	case 常量1：语句

​	case 常量2：语句

…

​	case 常量n：语句

​	default: 语句

}

case后要用break

多个case标号可以共用一组执行语句：

case’A’:
case’B’:
case’C’:printf(“>60”);break;





# 指针

i_pointer=&i                   //将i的地址存放到i_pointer中

将3送到变量i_pointer所指向的单元   *i_pointer表示i_pointer指向的对象
*i_pointer=3         

指针是一个地址，而指针变量是存放地址的变量

### 怎样定义指针

int *pointer_1=&a       //定义指针变量pointer_1,指向a

### 如何引用指针变量

*p=1       //表示将整数1赋给p当前所指向的变量，如果p指向变量a，则相当于把1赋给a,即a=1

### 通过指针引用数组

a是个数组名
p=a        //p的值是数组a首元素（即a[0]）的地址

如果指针变量p已指向数组中的一个元素，则**p+1指向同一数组中的下一个元素，p-1指向同一数组中的上一个元素**

（a+i）是a数组中序号为i的元素的地址，*（a+i）是该元素的值

1.***p++**；

由于++与*****同优先级，结合方式自右而左，因此等价于***(p++)**.先引用p的值，实现*p的运算，然后使p自增加一。

2.***(p++)**与***(++p)**区别

若初值为a(即&a[0])
前者先取***p**的值，然后使p加一,得到a[0]的值，
后者先使p加一，再取***p**,得到a[1].

3.**++(*p)**

表示所指向的元素值加一(不是指针值)





# 结构体





















